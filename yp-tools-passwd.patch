--- yp-tools-2.6/src/yppasswd.c.passwd	Fri Mar 22 19:27:01 2002
+++ yp-tools-2.6/src/yppasswd.c	Mon Mar 25 10:31:55 2002
@@ -46,6 +46,9 @@
 #include <locale.h>
 #include <libintl.h>
 #include <sys/param.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include <rpcsvc/yp_prot.h>
 #include <rpcsvc/ypclnt.h>
 #ifdef HAVE_RPC_CLNT_SOC_H
@@ -432,11 +435,44 @@
 
 #endif
 
+#define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
+
+static void
+create_random_salt (char *salt, int num_chars)
+{
+  int fd;
+  unsigned char c;
+  int i;
+  int res;
+  
+  fd = open("/dev/urandom", O_RDONLY);
+
+  for (i = 0; i < num_chars; i++)
+    {
+      res = 0;
+      
+      if (fd != 0)
+	res = read (fd, &c, 1);
+
+      if (res != 1)
+	c = random();
+      
+      salt[i] = bin_to_ascii(c & 0x3f);
+    }
+  
+  salt[num_chars] = 0;
+
+  if (fd != 0)
+    close (fd);
+}
+
+
 int
 main (int argc, char **argv)
 {
   char *s, *progname, *domainname = NULL, *user = NULL, *master = NULL;
   int f_flag = 0, l_flag = 0, p_flag = 0, error, status;
+  int has_md5_passwd = 0;
   struct yppasswd yppwd;
   struct passwd *pwd;
   CLIENT *clnt;
@@ -447,6 +483,8 @@
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
+  srandom (time (NULL));
+  
   if ((s = strrchr (argv[0], '/')) != NULL)
     progname = s + 1;
   else
@@ -593,27 +631,50 @@
       cp = stpcpy (hashpass, "##");
       strcpy (cp, pwd->pw_name);
 
+      if (strncmp(pwd->pw_passwd, "$1$", 3) == 0)
+	has_md5_passwd = 1;
+      
       /* We can't check the password with shadow passwords enabled. We
        * leave the checking to yppasswdd */
       if (uid != 0 && strcmp (pwd->pw_passwd, "x") != 0 &&
 	  strcmp (pwd->pw_passwd, hashpass ) != 0)
-        if (strcmp (crypt (s, pwd->pw_passwd), pwd->pw_passwd))
-          {
-            fprintf (stderr, _("Sorry.\n"));
-	    return 1;
-          }
+	{
+	  int passwdlen;
+	  char *sane_passwd;
+
+	  passwdlen = strlen (pwd->pw_passwd);
+	  /* Some systems (HPU/X) store the password aging info after
+	   * the password (with a comma to separate it). To support
+	   * this we cut the password after the first invalid char
+	   * after the normal 13 ones. We can't cut at the first
+	   * invalid char, since MD5 uses $ in the first char.
+	   */
+	  if (passwdlen > 13)
+	    passwdlen = 13 + strspn(pwd->pw_passwd + 13,
+				    "abcdefghijklmnopqrstuvwxyz"
+				    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+				    "0123456789./");
+
+	  sane_passwd = alloca (passwdlen + 1);
+	  strncpy (sane_passwd, pwd->pw_passwd, passwdlen);
+	  sane_passwd[passwdlen] = '\0';
+	    
+	  if (strcmp (crypt (s, sane_passwd), sane_passwd))
+	    {
+	      fprintf (stderr, _("Sorry.\n"));
+	      return 1;
+	    }
+	}
       yppwd.oldpass = strdup (s);
     }
 
   if (p_flag)
     {
-#define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
 #ifdef USE_CRACKLIB
       char *error_msg;
 #endif /* USE_CRACKLIB */
-      char *buf, salt[2], *p = NULL;
+      char *buf, salt[12], *p = NULL;
       int tries = 0;
-      time_t tm;
 
       buf = (char *) malloc (129);
 
@@ -662,9 +723,15 @@
 	    }
 	}
 
-      time (&tm);
-      salt[0] = bin_to_ascii (tm & 0x3f);
-      salt[1] = bin_to_ascii ((tm >> 6) & 0x3f);
+      if (!has_md5_passwd)
+	create_random_salt (salt, 2);
+      else
+	{
+	  /* The user already had a MD5 password, so it's safe to
+	   * use a MD5 password again */
+	  strcpy (salt, "$1$");
+	  create_random_salt (salt+3, 8);
+	}
 
       yppwd.newpw.pw_passwd = strdup (crypt (buf, salt));
     }
